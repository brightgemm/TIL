# SQLD

​      

## 제1장 데이터 모델링의 이해

### 01. 엔터티(Entity)

#### 엔터티의 개념

- 업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것
- 업무상 관리가 필요한 대상으로 그 대상들 간에 동질성을 지닌 인스턴스들이나 그들이 행하는 행위의 집합



#### 엔터티와 인스턴스

- 엔터티는 대부분 사각형으로 표현
  - ![[그림 Ⅰ-1-15] 엔터티와 인스턴스](https://dataonair.or.kr/publishing/img/knowledge/SQL_023.jpg)

- 엔터티와 인스턴스 표기법
  - ![[그림 Ⅰ-1-16] 엔터티에 대한 표기법](https://dataonair.or.kr/publishing/img/knowledge/SQL_024.jpg)



#### 엔터테의 특징

- 업무에서 필요로 하는 정보
- 식별 가능해야 함
- 인스턴스의 집합: 두 개 이상의 인스턴스 집합
- 업무 프로세스에 의해 이용되어야 함
- 속성을 포함: 예외적으로 관계엔터티의 경우 주식별자 속성만 가지고 있어도 인정
- 관계의 존재: 다른 엔터티와 최소 한 개 이상의 관계가 존재해야 함
  - 관계를 생략하여 표현하는 경우
    - 통계성 엔터티 도출, 코드성 엔터티 도출, 시스템 처리시 내부 필요에 의한 엔터티 도출



#### 엔터티의 분류

- 유무형에 따른 분류
  - 유형엔터티: Ex) 사원 물품, 강사 등
  - 개념엔터티: Ex) 조직, 보험상품 등
  - 사건엔터티: Ex) 주문, 청구, 미납 등
- 발생시점에 따른 분류
  - 기본엔터티(부서, 고객, 상품, 자재 등) 
  - -> 중심엔터티(계약, 사고, 청구, 주문, 매출 등) 
  - -> 행위엔터티(주문목록, 사원변경이력 등)
- 스스로 생성 여부: 독립엔터테 vs 의존엔터티



#### 엔터티의 명명

- 현업업무에서 사용하는 용어 사용
- 약어 사용 지양
- 단수 명사 사용
- 유일한 이름
- 생성 의미대로 이름 부여

​     

### 02. 속성(Attribute)

#### 속성의 개념

- 업무에서 필요로 하는 인스턴스로 관리하고자 하는, 의미상 더 이상 분리되지 않는 **최소의 데이터 단위**



#### 엔터티/인스턴스/속성/속성값

- 엔터티에는 두 개 이상의 인스턴스 집합이며, 두개 이상의 속성을 가짐
- 각각의 인스턴스는 속성의 집합이며 하나의 인스턴스는 각각의 속성에 대해 한 개의 속성값(value)만을 가질 수 있음
- 하나의 속성은 하나의 인스턴스에만 존재할 수 있으며, 한 개의 속성값을 가짐
- ![[그림 Ⅰ-1-25] 엔터티-속성의 관계](https://dataonair.or.kr/publishing/img/knowledge/SQL_033.jpg)



#### 속성의 특징

- 해당 업무에서 필요하고 관리하고자 하는 정보
- 정규화 이론에 근간하여 정해진 주실별자에 함수적 종속성을 가져야 함
- 하나의 속성은 한 개의 속성값을 가짐: 다중값일 경우 1차 정규화 또는 별도의 엔터티를 이용하여 분리



#### 속성의 분류

- **속성의 특성에 따른 분류**
  - 기본속성
  - 설계속성: 데이터 모델링 등 업무상 필요에 의해 새로 만들거나 변형하여 정의하는 속성. 일련번호, 부서코드 등
  - 파생속성: 다른 속성에 영향을 받아 발생하는 속성. 보통 계산 값. 데이터 정합성 유지를 위해 유의해야 할 점이 많음

- 엔터티 구성방식에 따른 분류
  - PK 속성: 엔터티를 식별할 수 있는 속성
  - FK속성: 다른 엔터티와의 관계에서 포함된 속성
  - 일반속성: PK, FK에 포함되지 않은 속성
- 세부 의미 분리 여부에 따른 분류: 단순형(나이, 성별) vs 복합형(주소- 시, 구, 동)



#### 도메인(Domain)

- 각 속성값의 범위
- 엔터티 내에서 속성에 대한 데이터 타입과 크기, 제약사항을 지정하는 것



#### 속성의 명명

- 해당 업무에서 사용하는 이름
- 서술식 속성명 지양. 명사형 사용
- 약어 사용 지양
- 유일성 확보

​      

### 03. 관계(Relationship)

#### 관계의 개념

- 엔터티의 인스턴스 사이의 논리적인 연관성
- 존재의 형태로서나 행위로서 서로에게 연관성이 부여된 상태
- 페어링: 엔터티 안에 인스턴스가 개별적으로 관계를 가지는 것
- 페어링의 집합 = 관계
  - ![[그림 Ⅰ-1-31] 관계의 패어링](https://dataonair.or.kr/publishing/img/knowledge/SQL_039.jpg)



#### 관계의 분류

- 존재에 의한 관계 : Ex) 부서 - 사원 => 연관관계(실선)
- 행위에 의한 관계: Ex) 고객 - 주문 => 의존관계(점선)



#### 관계의 표기법

- 관계명(membership): 관계의 이름
  - ![[그림 Ⅰ-1-33] 관계의 관계명](https://dataonair.or.kr/publishing/img/knowledge/SQL_041.jpg)
- 관계차수(Cardinality): 1:1, 1:m, m:m
  - ![[그림 Ⅰ-1-34] 관계차수(1:1)](https://dataonair.or.kr/publishing/img/knowledge/SQL_042.jpg)
  - ![[그림 Ⅰ-1-35] 관계차수(1:M)](https://dataonair.or.kr/publishing/img/knowledge/SQL_043.jpg)
  - ![[그림 Ⅰ-1-36] 관계차수(M:M)](https://dataonair.or.kr/publishing/img/knowledge/SQL_044.jpg)
- 관계선택사양(Optionality): 필수, 선택
  - ![[그림 Ⅰ-1-38] 관계선택참여](https://dataonair.or.kr/publishing/img/knowledge/SQL_046.jpg)



#### 관계의 정의 및 읽는 방법

- 관계 체크사항
  - 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가?
  - 두 개의 엔터티 사이에 정보의 조합이 발생되는가?
  - 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?
  - 업무기술서, 장표에 관계연결을 가능하게 하는 **동사(Verb)**가 있는가?
- 관계 읽기
  - ![[그림 Ⅰ-1-39] 관계의 읽는 방법](https://dataonair.or.kr/publishing/img/knowledge/SQL_047.jpg)

​       

### 04. 식별자(Identifiers)

#### 식별자의 개념

- 하나의 엔터티에 구성되어 있는 여러 개의 속성 중에 엔터티를 대표할 수 있는 속성
- 하나의 엔터티는 반드시 하나의 유일한 식별자가 존재
- 식별자 vs 키: 식별자는 논리 데이터 모델링에서, 키는 물리 데이터 모델링에서 사용



#### 식별자의 특징

- 주식별자
  - 유일성: 모든 인스턴스들이 유일하게 구분
  - 최소성: 유일성을 만족하는 최소의 속성 수 Ex) 사원번호+사원분류코드를 식별자로 사용(x)
  - 불변성: 자주 변하지 않는 값
  - 존재성: 주식별자가 지정되면 반드시 값이 존재
- 외부식별자
  - 참조무결성 제약조건(referential intergrity)



#### 식별자 분류 및 표기법

- 식별자 분류
  - 대표성 여부: 주식별자 vs 보조식별자
  - 스스로 생성 여부: 내부식별자 vs 외부식별자
  - 단일 속성 여부: 단일식별자 vs 복합식별자
  - 대체 여부: 본질식별자 vs 인조식별자
- 식별자 표기법
  - ![[그림 Ⅰ-1-42] 식별자의 분류-데이터 모델](https://dataonair.or.kr/publishing/img/knowledge/SQL_052.jpg)



#### 주식별자 도출기준

- 해당 업무에서 자주 이용되는 속성을 주식별자로 지정
- 명칭, 내역 등과 같이 이름으로 기술 지양
  - 부서명은 부서코드를 부여하여 코드엔터티에 등록한 후 부서코드로 주식별자 지정 또는 부서번호를 주식별자로 + 부서명을 보조식별자로 활용 가능
- 복합식별자로 구성할 경우 너무 많은 속성이 포함되는 것 지양
  - 속성이 많아지면 새로운 인조식별자를 생성하여 모델 구성하는 것이 좋음



#### 식별자관계와 비식별자관계에 따른 식별자

- 식별자관계 vs 비식별자관계
  - 엔터티에 주식별자가 지정되고 엔터티간 관계를 연결하면 부모쪽의 주식별자를 자식엔터티의 속성으로 내려보냄. 이 때 자식엔터티에서 부모엔터티로부터 받은 외부식별자를 자신의 주식별자로 이용할 것인지 또는 부모와 연결되는 속성으로만 이용할 것인지 결정해야 함
  - ![[표 Ⅰ-1-10] 식별자와 비식별자관계 비교](https://dataonair.or.kr/publishing/img/knowledge/SQL_070.jpg)
- 식별자관계: 부모엔터티의 주식별자를 자식엔터티의 주식별자로 이용하는 경우
  - null값이 오면 안되므로 반드시 부모엔터티가 생성되어야 자식 엔터티가 생성 되는 경우
  - 부모엔터티의 속성만을 주식별자로 사용하면 1:1의 관계, 여러 부모엔티티 속성+자기 자신의 속성을 주식별자로 사용하면 1:m의 관계
- 비식별자관계: 부모엔터티의 주식별자를 속성으로만 사용하는 경우
  - 자식엔터티에서 받은 속성이 필수값이 아니어도 될 때. 부모없는 자식이 생성 되는 경우
  - 엔터티별로 데이터의 생명주기를 다르게 관리할 경우
  - 여러 개의 엔터티가 하나의 엔터티로 통합되어 있을 때, 각각의 엔터티가 별도의 관계를 가질 경우
  - 자식엔터티에 별도의 주식별자를 생성하는 것이 더 유리하다고 판단될 때

​     

### 05. 데이터 모델의 이해

#### 모델링의 이해

- 모델링의 정의
  - 현실세계를 추상화, 단순화 명확화하기 위해 일정한 표기법에 의해 표현하는 기법
  - 시스템의 대상이 되는 업무를 분석하여 정보시스템으로 구성하는 과정에서 업무의 내용과 정보시스템의 모습을 적절한 표기법(Notation)으로 표현하는 것
- 모델링의 특징
  - 추상화(=모형화 가설적): 다양한 현상을 일정한 표기법에 의해 표현
  - 단순화: 복잡한 현실세계를 약속된 규약에 의해 제한된 표기법이나 언어로 표현
  - 명확화: 애매모호함을 제거하고 정확하게 현상을 기술하는 것
- 모델링의 세 가지 관점
  - 데이터 관점(What, Data): 업무가 어떤 데이터와 관련이 있는지, 데이터간의 관계는 무엇인지에 대해 모델링
  - 프로세스 관점(How, Process): 업무가 실제하고 있는 일은 무엇인지 또는 무엇을 해야하는지를 모델링
  - 데이터와 프로세스의 상관관점(Interaction): 업무가 처리하는 일의 방법에 따라 데이터는 어떻게 영향을 받고 있는지 모델링



#### 데이터 모델의 기본 개념의 이해

- 데이터 모델링의 정의
  - 정보시스템을 구축하기 위한 데이터 관점의 업무 분석 기법
  - 현실세계의 데이터(What)에 대해 약속된 표기법에 의해 표현하는 과정
  - 데이터베이스를 구축하기 위한 분석, 설계의 과정
- 데이터 모델링의 목적
  - 정보시스템 구축의 대상이 되는 업무내용을 정확하게 분석
    - 업무정보를 구성하는 기초가 되는 정보들을 일정한 표기법에 의해 표현
  - 분석된 모델로 실제 데이터베이스를 생성하여 개발 및 데이터 관리에 사용
- 데이터 모델의 기능
  - 시스템을 현재 또는 원하는 모습으로 가시화
  - 시스템의 구조와 행동 명세화
  - 시스템을 구축하는 구조화된 틀 제공
  - 시스템을 구축하는 과정에서 결정한 것을 문서화
  - 다양한 영역에 집중하기 위해 다른 영역의 세부 사항은 숨기는 다양한 관점 제공
  - 특정 목표에 따라 구체화된 상세 수준의 표현방법 제공



#### 데이터 모델링의 중요성 및 유의점

- 파급효과(Leverage)
  - 데이터 구조의 변경으로 인한 일련의 변경작업은 전체 시스템 구축에서 큰 위험요소. 따라서 시스템 구축 작업 중 데이터 설계는 매우 중요함
- 복잡한 정보 요구사항의 간결한 표현(Conciseness)
  - 데이터 모델은 구축할 시스템의 정보 요구사항과 한계를 가장 명확하고 간결하게 표현할 수 있는 도구. 데이터 모델은 설계 도면에 해당
  - 데이터 모델은 시스템을 구축하는 만은 관련자들이 설계자들이 정보요구사항을 이해하고, 어플리케이션을 개발하고, 데이터 정합성을 유지할 수 있도록 함
- 데이터 품질(Data Quality)
  - 데이터의 문제는 오랜 기간 숙성된 데이터를 전략적으로 활용하려고 하는 시점에 문제가 대두됨
  - 데이터 품질의 문제가 야기되는 중대한 이유 중 하나는 데이터 구조의 문제. 중복 데이터의 미정의, 데이터 구조의 비즈니스 정의 불충분, 동일한 성격의 데이터를 통합하지 않아 나타나는 데이터 불일치 등
    - 중복(Duplication): 데이터베이스가 여러 장소에 같은 정보를 저장하는 것 방지
    - **비유연성(Inflexibility)**: 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델링은 데이터/프로세스의 **작은 변화가 데이터베이스에 중대한 변화를 일으킬 가능성을 낮춤**
    - **비일관성(Inconsistency)**: 데이터 중복이 없어도 비일관성 발생. 데이터 모델링을 할 때 데이터간 상호 연관 관계에 대한 명확한 정의를 통해 예방



#### 데이터 모델링의 3단계 진행

![[그림 Ⅰ-1-3] 현실세계와 데이터베이스 사이의 모델](https://dataonair.or.kr/publishing/img/knowledge/SQL_004.jpg)

![[표 Ⅰ-1-1] 개념-논리-물리데이터 모델](https://dataonair.or.kr/publishing/img/knowledge/SQL_005.jpg)

- 개념적 데이터 모델링
  - 조직의 데이터 요구 공식화를 통한 기능
    - 시스템 개발자가 데이터 요구 사항 발견하는 것을 지원: 추상적이기 때문에 상위 문제에 대한 구조화가 쉽고, 사용자와 개발자가 시스템 기능에 대해 논의할 수 있는 기반을 형성함
    - 현 시스템이 어떻게 변형되어야 하는가를 이해하는데 유용: 고립된 시스템도 추상적 모델링을 통해 쉽게 표현되고 설명됨
  - 핵심 엔터티와 그들간의 관계 발견
  - 엔터티-관계 다이어그램으로 표현: 어떠한 데이터가 중요한지 나타나기 위해 사용됨
- 논리적 데이터 모델링
  - 데이터베이스 설계 프로세스의 input. 비즈니스 정보의 논리적인 구조와 규칙을 명확하게 표현하는 기법, 과정
  - 데이터 모델링 과정에서 가장 핵심
  - 정규화를 통해 모델의 일관성을 확보하고 중복 제거하여 속성이 가장 적절한 엔터티에 배치 -> 신뢰성 있는 데이터 구조
  - 논리 데이터 모델의 상세화: 식별자 확정, 정규화, m:m관계 해소, 참소 무결성 규칙 정의, 이력 관리 전략 정의
- 물리적 데이터 모델링
  - 논리 데이터 모델이 데이터 저장소로서 어떻게 컴퓨터 하드웨어에 표현될 것인가를 다룸
  - 물리적 스키마: 데이터가 어떻게 컴퓨터에 물리적으로 저장될 것인가에 대한 정의
  - 물리적 저장구조(테이블, 칼럼 등)와 사용될 저장 장치, 자료를 추출하기 위해 사용될 접근 방법 등 결정



#### 프로젝트 생명주기에서 데이터 모델링

- 폭포수 기반: 모델링의 위치가 분석과 설계단계로 명확하게 구분하여 정의
- 정보공학이나 구조적 방법론에서는 분석단계(업무중심의 논리적 데이터 모델링)와 설계단계(물리적인 데이터 모델링) 수행
- 나선형 모델: 업무 크기에 따라 논리적 데이터 모델과 물리적 데이터 모델이 분석, 설계 양쪽에서 수행하며, 분석단계에서 논리적 데이터 모델이 더 많은 비중을 차지함
- 데이터축과 애플리케이션축으로 구분되어 프로젝트가 진행되면서 지속적인 상호검증을 통해 단계별 완성도를 높임
- 객체지향 개념은 데이터 모델링과 프로세스 모델링을 구분하지 않고 일체형으로 진행



#### 데이터 모델링에서 데이터독립성의 이해

- 데이터독립성의 필요성

  - 어떤 단위에 대해 독립적인 의미를 부여하고 그것을 효과적으로 구현하게 되면 고유한 특징을 명확하게 할 뿐만 아니라 다른 기능의 변경으로부터 쉽게 변경되지 않고 자신의 고유한 기능을 그대로 제공할 수 있다는 장점을 가짐
  - 유지보수 비용 증가
  - 데이터 중복성 증가
  - 데이터 복잡도 증가
  - 요구사항 대응 저하

- 데이터독립성 확보 효과

  - 각 view의 독립성을 유지하고 계층별 view에 영향을 주지 않고 변경 가능
  - 단계별 스키마에 따라 데이터 정의어와 데이터 조작어가 다름을 제공

- 데이터베이스 3단계 구조(ANSI/SPARC 표준 모델)

  - ![[그림 Ⅰ-1-6] 데이터독립성](https://dataonair.or.kr/publishing/img/knowledge/SQL_008.jpg)

  

  - ![[그림 Ⅰ-1-2] 데이터독립성 구성요소](https://dataonair.or.kr/publishing/img/knowledge/SQL_009.jpg)
  - 데이터 모델링은 통합관점의 뷰를 가지고 있는 개념 스키마를 만들어가는 과정

- 데이터독립성의 종류
  - ![[그림 Ⅰ-1-3] 논리적, 물리적 데이터독립성](https://dataonair.or.kr/publishing/img/knowledge/SQL_010.jpg)

- 데이터독립성에서의 사상(mapping): 상호 독립적인 개념을 연결시켜주는 다리
  - ![[표 Ⅰ-1-4] 사상(Mapping)](https://dataonair.or.kr/publishing/img/knowledge/SQL_011.jpg)
  - 데이터독립성을 보장하기 위해서는 사상을 하는 스크립트(DDL)를 DBA가 필요할 때마다 변경해야 함



#### 데이터 모델링의 중요한 세 가지 개념

- 데이터 모델링의 세 가지 요소: Things, Attributes, Relationships

  - 엔터티: 사물이나 사건을 바라볼 때 전체를 지칭
  - 속성: 엔터티가 가지는 세부적인 사항
  - 관계: 다른 엔터티와의 연관성

- 단수와 집합의 명명

  - ![[표 Ⅰ-1-5] 용어의 구분정의](https://dataonair.or.kr/publishing/img/knowledge/SQL_013.jpg)

  - 일반적으로는 단수와 복수 관계 없이 '관계'라고 표현하는 경우가 많음



#### 데이터 모델링의 이해관계자

- 정보시스템을 구축하는 모든 이해관계자들은 데이터 모델링도 전문적으로 할 수 있거나 완성된 모델을 정확하게 해석할 수 있어야 함



#### 데이터 모델의 표기법 ERD의 이해

- 데이터 모델 표기법
  - ERD(Entity Relationship Diagram): 엔터티-사각형, 관계-마름모, 속성-타원형
  - 해당 업무에서 데이터의 흐름과 프로세스와의 연광성을 이야기하는 데에 중요한 표기법이자 산출물 -> 의사소통 원활
- ERD 작업순서
  - ![[그림 Ⅰ-1-9] ERD 작업순서](https://dataonair.or.kr/publishing/img/knowledge/SQL_017.jpg)



#### 좋은 데이터 모델의 요소

- 완전성(Completeness): 필요한 모든 데이터가 데이터 모델에 정의되어 있어야 함
- 중복배제(Non-Redundancy)
- 업무규칙(Business Rules): 업무규칙을 데이터 모델에 표현하고 모든 사용자가 공유. 논리 데이터 모델 단계에서 중요
- 데이터 재사용(Data Reusability): 데이터 통합성과 독립성이 중요
- 의사소통(Communication): 데이터 분석과정에서 도출된 업무 규칙들이 데이터모델에 엔터티, 서브타입, 속성, 관계 등의 형태로 최대한 자세하게 표현되어야 함 -> 구성원들 모두가 동일한 의미로 받아들일 수 있음
- 통합성(Integration): 개별 업무별 단위가 아닌 전체 조직 관점에서 동일한 데이터는 한번만 정의한 뒤 다른 영역에서 참조, 활용하는 것이 바람직함





## 제2장 데이터 모델과 성능

### 01. 성능 데이터 모델링의 개요

#### 성능 데이터 모델링의 정의

- 성능 데이터 모델링: 데이터베이스 성능 향상을 목적으로 설계단계의 데이터 모델링 때부터 정규화, 반정규화 테이블통합, 테이블분할, 조인구조, PK, FK 등 여러 사항을 반영하는 것

- 성능이 저하되는 원인
  - 데이터 모델 구조에 의한 성능 저하
  - 대용량 데이터로 인한 불가피한 성능 저하
  - 인덱스 특성을 고려하지 않은 인덱스 생성으로 인한 성능 저하
- 일반적인 성능은 데이터 조회의 성능. 데이터 입력, 수정, 삭제는 일시적, 단건 처리가 많기 때문



#### 성능 데이터 모델링 수행시점

- 분석/설계 단계에서부터 성능에 대한 데이터 설계를 하지 않으면 시간이 지날수록 성능개선의 비용이 증가하게 됨



#### *성능 데이터 모델링 고려사항

- 데이터 모델링을 할 때 정규화를 정확하게 수행
- 데이터베이스 용량산정 수행
- 데이터베이스에 발생되는 트랜잭션의 유형 파악: CURD 매트릭스, 시퀀스 다이어그램
- 용량과 트랜잭션의 유형에 따라 **반정규화** 수행
- 이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 등 수행
- 성능관점에서 데이터 모델 검증



### 02. 정규화의 성능

#### 정규화를 통한 성능 향상 전략

- 데이터 중복성 제거, 데이터 관심사별 처리 -> 성능 향상
- ![[그림 Ⅰ-2-3] 정규화 수행과 성능](https://dataonair.or.kr/publishing/img/knowledge/SQL_074.jpg)



#### 함수적 종속성에 근거한 정규화 수행 필요

- 함수의 종속성: 데이터들이 어떤 기준값에 의해 종속되는 현상. 이 때 기준값을 결정자(Determinant), 종속되는 값을 종속자(Depanent)라고 함



#### [기타] n차 정규화

- 1차 정규화: 기본키에 대해 반복되는 값이 있을 때
  - Ex) pk=주문번호. 1월재고수량, 2월재고수량,...
- 2차 정규화: 복합식별자일 때 하나의 식별자에만 종속되는 칼럼이 있을 경우
  - Ex) pk=주문번호+주문일자 일 때, 주문시간과 주문장소가 주문일자에만 종속되는 경우
- 3차 정규화: 기본키 외의 다른 칼럼이 다른 칼럼을 결정지을 때
  - Ex) pk=student_id. street, city, state, zip
    - zip칼럼이 street, city, state를 결정하게 됨
    - address 테이블을 생성하여 zip, street, city, state로 구성하고, 기존 테이블은  zip만 남도록 변경





### 03. 반정규화의 성능

#### 반정규화(=역정규화)를 통한 성능 향상 전략

- 반정규화의 정의
  - 협의: 데이터 중복하여 성능 향상
  - 광의: 성능 향상을 위해 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정
- 반정규화의 목적
  - 테이블의 중복성, 칼럼의 중복성, 관계의 중복성 활용하여 데이터조회 성능 향상
- 반정규화 적용방법
  - 칼럼 반정규화 -> 데이터 무결성을 깨뜨리는 결정적인 역할을 하는 경우가 많음
  - 테이블의 반정규화
  - 관계의 반정규화
- 반정규화 절차: 반정규화 대상조사 -> 다른 방법유도, 검토 -> 반정규화 적용
  - ![[그림 Ⅰ-2-13] 반정규화 절차](https://dataonair.or.kr/publishing/img/knowledge/SQL_090.jpg)



#### 반정규화 기법

- 테이블 반정규화
  - ![[표 Ⅰ-2-1] 테이블의 반정규화](https://dataonair.or.kr/publishing/img/knowledge/SQL_091.jpg)
- 칼럼 반정규화
  - ![[표 Ⅰ-2-2] 칼럼의 반정규화](https://dataonair.or.kr/publishing/img/knowledge/SQL_092.jpg)
- 관계 반정규화
  - ![[표 Ⅰ-2-3] 관계의 반정규화 / 테이블과 칼럼의 반정규화는 데이터 무결성에 영향을 미치게 되나 관계의 반정규화는 데이터 무결성을 깨뜨릴 위험을 갖지 않고서도 데이터처리 성능을 향상시킬 수 있는 반정규화의 기법이 된다. 데이터 모델 전체가 관계로 연결되어 있고 관계가 서로 먼 친척간의 조인관계가 빈번하게 되어 성능저하가 예상이 된다면 관계의 반정규화를 통해 성능향상을 도모할 필요가 있다.](https://dataonair.or.kr/publishing/img/knowledge/SQL_093.jpg)

- 테이블과 칼럼 반정규화는 데이터 무결성에 영향을 미치기 때문에 주의해야 함
- 데이터 조회 시에는 성능 향상, 데이터 입력/수정/삭제 시에는 성능이 떨어짐



#### [기출] 반정규화시 고려요소

- 다량의 데이터인 경우 파티션 또는 클러스터링을 활용
- 전후 위치의 레코드 탐색 시 window function 활용
- 반정규화 정보에 대한 재현의 적시성으로 판단(다량의 조인이 불가피 할 때 조인 감소를 위해 반정규화 사용)



### 04. 대량 데이터에 따른 성능

#### 대량 데이터 발생에 따른 테이블 분할 개요

- 트랜잭션이 분산 처리 될 수 있도록 테이블 단위에서 분할의 방법을 적용
- SQL문장에서 데이터를 처리하기 위한 I/O양이 증가하면 테이블 성능이 저하됨
- 인덱스를 이용하여 해결하는 방법은 인덱스 깊이와 크기가 커지므로 성능 저하가 수반됨
- 칼럼이 많아지면 여러 블록에서 데이터를 I/O 해야 하는 문제 발생
- **로우 체이닝(Row Chaining)**: 로우 길이가 길어 데이터 블록 하나에 저장되지 않고 두 개 이상의 블록에 걸쳐 저장되어 있는 형태
- **로우 마이그레이션(Row Migration)**: 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식
- 로우 체이닝과 로우 마이크레이션이 발생하여 많은 블록에 데이터가 저장되면 성능 저하



#### 한 테이블에 많은 수의 칼럼을 가진 경우

- 칼럼수가 많은 테이블에서 넓은 범위의 데이터를 가져오려면 디스크 I/O양이 증가함
- 칼럼수가 많은 테이블의 1:1 분리로 성능 개선 가능



#### 대량 데이터 저장 및 처리로 인한 성능

- **대랑 데이터가 예상될 경우 파티셔닝을 적용하거나 PK에 의해 테이블 분할 가능**
- Oracle의 테이블 분할
  - LIST PARTITION(특정 값 지정)
    - 핵심적인 코드값 등으로 PK가 구성되어 있는 대량 데이터
    - Ex) 사업소코드별로 고객 데이터 분할
  - RANGE PARTITION(범위)
    - 프로그램에서 하나의 테이블에 접근하면 내부적으로 범위로 구분된 테이블에서 트랜잭션 처리
    - 데이터 보관주기에 따라 테이블 데이터를 쉽게 삭제 가능하여 테이블 관리 용이
    - Ex) 년월별로 요금 데이터 분할
  - HASH PARTITION(해시)
  - COMPOSITE PARTITION(범위+해시 복합)



#### 테이블에 대한 수평분할/수직분할 절차

1. 데이터 모델링 완성
2. 데이터베이스 용량산정
3. 대량 데이터가 처리되는 테이블의 트랜잭션 처리 패턴 분석
   - 테이블을 1:1형태로 분리 검토
   - 파티셔닝 전략, 클러스터링 전량
4. 칼럼 단위/로우단위 중 집중화된 단위로 테이블 분리 검토



#### [기출] 파티셔닝(Partitionning)

- 논리적으로는 한 개의 테이블이나 물리적으로 여러 개의 테이블로 분리하여 데이터 액세스 성능을 향상시키고 데이터 관리방법도 개선하는 기법

​    

### 05. 데이터베이스 구조와 성능

#### 슈퍼타입/서브타입 모델의 성능 고려 방법

- 슈퍼/서브타입 데이터 모델(Extended ER Model)
  - 업무를 구성하는 데이터의 특징을 공통점(슈퍼타입)과 차이점(서브타입)을 고려하여 효과적으로 표현 가능
  - 물리적인 데이터 모델로 변환할 때 선택의 폭을 넓힐 수 있음
  - 논리적 데이터 모델에서 이용, 분석단계에서 많이 쓰이는 모델
- 슈퍼/서브타입 데이터 모델의 변환
  - ![[그림 Ⅰ-2-25] 슈퍼타입과 서비스타입의 변환](https://dataonair.or.kr/publishing/img/knowledge/SQL_110.jpg)
  - 슈퍼/서브타입의 잘못된 변환으로 인한 성능 저하 사례
    - 트랜잭션은 항상 일괄로 처리하는데 테이블은 개별로 유지되어 Union 연산에 의해 성능 저하
    - 트랜잭션은 항상 서브타입 개별로 처리하는데 테이블을 하나로 통합되어 있어 많은 양의 데이터가 집약되어 있을 때
    - 트랜잭션은 항상 슈퍼+서브 타입을 공통으로 처리하는데 개별 또는 하나로 집약되어 있을 때
  - 슈퍼/서브타입 성능을 고려한 물리적인 데이터 모델로 변환할 때에는 데이터 양과 테이블에 발생되는 트랜잭션 유형에 따라 결정
- 슈퍼/서브타입 데이터 모델의 변환기술
  - 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성(1:1관계로 분리)
  - 슈퍼 + 서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼+서브 테이블로 구성
  - 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성
- 슈퍼/서브타입 데이터 모델의 변환 타입 비교
  - ![[표 Ⅰ-2-4] 슈퍼/서브타입 데이터 모델 변환타입 비교](https://dataonair.or.kr/publishing/img/knowledge/SQL_114.jpg)



#### 인덱스 특성을 고려한 PK/FK 데이터베이스 성능향상

- PK/FK 칼럼 순서와 성능개요
  - 인덱스는 PK/FK 칼럼 순서와 성능개요 데이터를 조회할 때 가장 효과적으로 처리될 수 있도록 접근 경로를 제공하는 오브젝트
  - 일반적으로 데이터베이스 테이블에서는 B*Tree 구조 많이 사용
  - 복합식별자일 때 PK순서에 대한 고려 필요
    - 인덱스 정렬구조를 이해한 상태에서 인덱스를 효율적으로 이용할 수 있도록 지정(PK순서 = 인덱스 순서)
    - 앞쪽에 위치한 속성의 값이 비교자로 있어야 효율이 좋음
    - 만약 where절에 인덱스1번 칼럼이 없다면 full scan을 해야하는 비효율 발생
    - ![[그림 Ⅰ-2-36] PK순서에 의한 인덱스 이용 범위](https://dataonair.or.kr/publishing/img/knowledge/SQL_124.jpg)



#### 물리적인 테이블에 FK제약이 없을 경우 인덱스 미생성으로 성능 저차

- 상속받은 FK에 대해 FK 인덱스를 생성함으로써 SQL 문장에서 조인이 발생할 때 성능 저하 예방



### 06. 분산 데이터베이스와 성능

#### 분산 데이터베이스의 개요

-  여러 곳으로 분산되어 있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스
- 논리적으로 동일한 시스템에 속하지만, 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터들의 모임. 물리적 장소 분산+논리적 사용자 통합 및 공유



#### 분산 데이터베이스의 투명성(Transparency) 조건

- 분할 투명성(단편화): 하나의 논리적 관계가 여러 단편으로 분할되어 단편 사본이 여러 장소에 저장
- 위치 투명성: 데이터 저장 장소 명시 불필요. 위치정보가 시스템 카탈로그에 유지되어야 함
- 지역사상 투명성: 지역 DBMS와 물리적 데이터베이스 사이의 mapping 보장. 각 지역시스템 이름과 무관한 이름 사용가능
- 중복 투명성: 데이터베이스 객체가 여러 장소에 중복되어 있는지 알 필요 없음
- 장애 투명성: 구성요소의 장애에 무관한 트랜잭션의 원자성 유지
- 병행 투명성: 다수 트랜잭션 동시 수행 시 결과의 일관성 유지, time stamp, 분산 2단계 locking 이용 구현



#### 분산 데이터베이스의 적용 방법 및 장단점

- 분산 데이터베이스 적용방법
  - 업무의 특징에 따라 데이터베이스 분산구조를 선택적으로 설계하는 능력 필요
- 분산 데이터베이스 장단점
  - 장점
    - 지역자치성, 점증적 시스템 용량 확장
    - 신뢰성과 가용성
    - 효용성과 융통성
    - 빠른 응답 속도와 통신비용 절감
    - 시스템 규모의 적절한 조절
    - 각 지역 사용자의 요구 수용 증대
  - 단점
    - 소프트웨어 개발 비용
    - 오류의 잠재성 증대
    - 처리 배용 증대
    - 설계, 관리의 복잡성과 비용
    - 불규칙한 응답 속도
    - 통제의 어려움
    - 데이터 무결성에 대한 위험



#### 분산 데이터베이스의 활용 방향성

- 업무 특징에 따라 분산 데이터베이스 활용 필요(과거에는 위치 중심의 분산설계)



#### 데이터베이스 분산구성의 가치

- 빠른 데이터 처리 성능 제공: 원거리 또는 다른 서버에 접속하여 처리하여 발생하던 네트워크 부하 및 트랜잭션 집중에 따른 성능 저하 해결



#### 분산 데이터베이스의 적용 기법

- 테이블 위치 분산: 정보 이용하는 형태가 각 위치별로 차이가 있을 경우
  - 테이블의 구조 동일, 테이블 중복 생성되지 않음
  - ![[그림 Ⅰ-2-41] 테이블별 위치 분산](https://dataonair.or.kr/publishing/img/knowledge/SQL_132.jpg)
  - ![[그림 Ⅰ-2-42] 테이블별 위치 분산](https://dataonair.or.kr/publishing/img/knowledge/SQL_133.jpg)
  - 테이블의 위치를 파악할 수 있는 도식화된 위치별 데이터베이스 문서 필요
- 테이블 분할 분산
  - 수평분할(로우 단위): 각 지사별로 사용하는 로우가 다를 때
    - ![[그림 Ⅰ-2-44] 테이블 수평분할](https://dataonair.or.kr/publishing/img/knowledge/SQL_135.jpg)
  - 수직분할(칼럼 단위): 모든 데이터가 각 지사별로 분리되어 있는 형태
    - 각각의 테이블에는 동일한 PK구조와 값을 가지고 있어야 함
    - ![[그림 Ⅰ-2-46] 테이블 수직분할 모델링](https://dataonair.or.kr/publishing/img/knowledge/SQL_137.jpg)
    - 중복 없음
- **테이블 복제 분산**: 동일한 테이블을 다른 지역이나 서버에서 동시에 생성하여 관리. 실시간이 아닌 배치에 의한 복제
  - 부분복제: 통합된 테이블은 본사에, 각 지사별로는 할당된 로우를 가지고 있는 형태
    - 본사 데이터 = 지사 데이터의 합
    - 지사간에는 데이터 중복 없으나 본사와 지사간에는 반드시 중복 발생
    - 지사의 데이터 입력, 수정, 삭제 -> 본사에서 이용
  - 광역복제: 통합된 테이블을 본사와 지사 모두 가지고 있는 형태
    - 본사에서는 데이터 관리, 지사에서는 데이터를 읽어 업무프로세스 발생시키는 것
    - 본사에서 데이터 입력, 수정, 삭제 -> 지사에서 이용
- 테이블 요약 분산: 데이터가 비슷하지만 다른 유형으로 존재하는 경우. 실시간이 아닌 야간에 수행
  - 분석요약(Rollip Summarization): 각 지사별로 존재하는 요약정보를 본사에서 통합하여 전체에 대한 요약정보를 다시 산출하는 방법
  - 통합요약(Consolidation Summarization): 각 지사별로 존재하는 다른 정보를 본사에서 취합하여 전체에 대한 요약정보를 다시 산출하는 방법
    - 각 지사는 타지사와 다른 요약정보를 가지고 있고, 본사는 각 지사의 요약정보를 같은 위치에 두는 것으로 통합



#### 분산 데이터베이스를 적용하면 좋은 경우

- 성능이 중요한 사이트에 적용해야 함
- 공통코드, 기준정보, 마스터 데이터 등에 대해 분산환경을 구성하면 성능 향상
- 실시간 동기화가 요구되지 않을 때, 거의 실시간의 업무적인 특징을 가지고 있을 때도 가능
- 특정 서버에 부하가 집중이 되어 부하를 분산시킬 때
- 백업 사이트(Disaster Recovery Site)를 구성할 때 간단하게 분산기능을 적용하여 구성



#### [기출] 

- GSI(Global Single Instance)는 통합 데이터베이스 구조